

# This file was *autogenerated* from the file the_matrix.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_50 = Integer(50); _sage_const_31337 = Integer(31337); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_12 = Integer(12)
import random

P = _sage_const_2 
N = _sage_const_50 
E = _sage_const_31337 

FLAG = b'crypto{??????????????????????????}'

def bytes_to_binary(s):
    bin_str = ''.join(format(b, '08b') for b in s)
    bits = [int(c) for c in bin_str]
    return bits

def binary_to_bytes(mat, length):
    # mat is a matrix/list of lists (rows) of bits
    bits = []
    for row in mat:
        bits.extend(row)
    # Pack bits into bytes
    out = bytearray()
    for i in range(_sage_const_0 , length, _sage_const_8 ):
        byte = _sage_const_0 
        for j in range(_sage_const_8 ):
            if i + j < length:
                byte = (byte << _sage_const_1 ) | int(bits[i + j])
        # Only append if there's at least 1 bit (i.e., full byte or final partial byte)
        out.append(byte)
    return bytes(out)

def generate_mat():
    while True:
        msg = bytes_to_binary(FLAG)
        msg += [random.randint(_sage_const_0 , _sage_const_1 ) for _ in range(N*N - len(msg))]

        rows = [msg[i::N] for i in range(N)]
        mat = Matrix(GF(_sage_const_2 ), rows)

        if mat.determinant() != _sage_const_0  and mat.multiplicative_order() > _sage_const_10 **_sage_const_12 :
            return mat

def load_matrix(fname):
    data = open(fname, 'r').read().strip()
    rows = [list(map(int, row)) for row in data.splitlines()]
    return Matrix(GF(P), rows)

def save_matrix(M, fname):
    open(fname, 'w').write('\n'.join(''.join(str(x) for x in row) for row in M))

#mat = generate_mat()

#ciphertext = mat^E
#save_matrix(ciphertext, 'flag.enc')


def eth_root_matrix(C, E):
    # Work in the polynomial ring that owns the minimal polynomial
    m = C.minimal_polynomial()
    R = m.parent(); t = R.gen()

    # We use the squarefree part to ensure coprime moduli for CRT
    msf = m.squarefree_part()
    fac = msf.factor()  # list of (f, multiplicity=1)

    residues = []
    moduli   = []

    for f, _ in fac:
        d = f.degree()
        invE = inverse_mod(E, _sage_const_2 **d - _sage_const_1 )  # exists for all d<=50 here
        # On this component, the E-th root is "raise to invE"
        residues.append( (t**invE) % f )
        moduli.append(f)

    # Chinese Remainder Theorem over polynomials
    h = crt(residues, moduli) % msf

    # Evaluate h at C to get M; sanity-check M^E == C
    M = h(C)
    if M**E != C:
        # Extremely unlikely here; would indicate a non-semisimple corner case
        # If this triggers, weâ€™d Hensel-lift to repeated factors, but for this challenge it shouldn't.
        raise RuntimeError("Root check failed: M**E != C")
    return M

def unpack_flag_from_matrix(M, flag_len_bytes):
    # Flatten rows, take the first flag_len_bytes*8 bits, pack MSB-first per byte
    bits = [int(M[i,j]) for i in range(M.nrows()) for j in range(M.ncols())]
    L = flag_len_bytes * _sage_const_8 
    bits = bits[:L]
    out = bytearray()
    for i in range(_sage_const_0 , L, _sage_const_8 ):
        byte = _sage_const_0 
        for b in bits[i:i+_sage_const_8 ]:
            byte = (byte << _sage_const_1 ) | b
        out.append(byte)
    return bytes(out)

def main():
    C = load_matrix('flag_the_matrix.enc')
    assert C.nrows() == N and C.ncols() == N
    M = eth_root_matrix(C, E)
    flag = unpack_flag_from_matrix(M, FLAG_LEN_BYTES)

    print(flag)
    try:
        print(flag.decode())
    except:
        pass

main()

