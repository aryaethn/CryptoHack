

# This file was *autogenerated* from the file solve_exceptional_curves.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16); _sage_const_10 = Integer(10); _sage_const_0xa15c4fb663a578d8b2496d3151a946119ee42695e18e13e90600192b1d0abdbb6f787f90c8d102ff88e284dd4526f5f6b6c980bf88f1d0490714b67e8a2a2b77 = Integer(0xa15c4fb663a578d8b2496d3151a946119ee42695e18e13e90600192b1d0abdbb6f787f90c8d102ff88e284dd4526f5f6b6c980bf88f1d0490714b67e8a2a2b77); _sage_const_0x5e009506fcc7eff573bc960d88638fe25e76a9b6c7caeea072a27dcd1fa46abb15b7b6210cf90caba982893ee2779669bac06e267013486b22ff3e24abae2d42 = Integer(0x5e009506fcc7eff573bc960d88638fe25e76a9b6c7caeea072a27dcd1fa46abb15b7b6210cf90caba982893ee2779669bac06e267013486b22ff3e24abae2d42); _sage_const_0x2ce7d1ca4493b0977f088f6d30d9241f8048fdea112cc385b793bce953998caae680864a7d3aa437ea3ffd1441ca3fb352b0b710bb3f053e980e503be9a7fece = Integer(0x2ce7d1ca4493b0977f088f6d30d9241f8048fdea112cc385b793bce953998caae680864a7d3aa437ea3ffd1441ca3fb352b0b710bb3f053e980e503be9a7fece); _sage_const_0x7f0489e4efe6905f039476db54f9b6eac654c780342169155344abc5ac90167adc6b8dabacec643cbe420abffe9760cbc3e8a2b508d24779461c19b20e242a38 = Integer(0x7f0489e4efe6905f039476db54f9b6eac654c780342169155344abc5ac90167adc6b8dabacec643cbe420abffe9760cbc3e8a2b508d24779461c19b20e242a38); _sage_const_0xdd04134e747354e5b9618d8cb3f60e03a74a709d4956641b234daa8a65d43df34e18d00a59c070801178d198e8905ef670118c15b0906d3a00a662d3a2736bf = Integer(0xdd04134e747354e5b9618d8cb3f60e03a74a709d4956641b234daa8a65d43df34e18d00a59c070801178d198e8905ef670118c15b0906d3a00a662d3a2736bf); _sage_const_3034712809375537908102988750113382444008758539448972750581525810900634243392172703684905257490982543775233630011707375189041302436945106395617312498769005 = Integer(3034712809375537908102988750113382444008758539448972750581525810900634243392172703684905257490982543775233630011707375189041302436945106395617312498769005); _sage_const_4986645098582616415690074082237817624424333339074969364527548107042876175480894132576399611027847402879885574130125050842710052291870268101817275410204850 = Integer(4986645098582616415690074082237817624424333339074969364527548107042876175480894132576399611027847402879885574130125050842710052291870268101817275410204850); _sage_const_4748198372895404866752111766626421927481971519483471383813044005699388317650395315193922226704604937454742608233124831870493636003725200307683939875286865 = Integer(4748198372895404866752111766626421927481971519483471383813044005699388317650395315193922226704604937454742608233124831870493636003725200307683939875286865); _sage_const_2421873309002279841021791369884483308051497215798017509805302041102468310636822060707350789776065212606890489706597369526562336256272258544226688832663757 = Integer(2421873309002279841021791369884483308051497215798017509805302041102468310636822060707350789776065212606890489706597369526562336256272258544226688832663757); _sage_const_2 = Integer(2)# solve_exceptional_curves.sage
# Recover the FLAG from output_exceptional_curves.txt using the curve & Bob pubkey in source_exceptional_curves.sage
# Requires: SageMath; PyCryptodome for AES (Crypto.Cipher)
import re, ast, hashlib
from pathlib import Path

# ---------- helpers ----------
def is_pkcs7_padded(message):
    padding = message[-message[-_sage_const_1 ]:]
    return all(padding[i] == len(padding) for i in range(_sage_const_0 , len(padding)))

def parse_hex_or_dec(s):
    s = s.strip()
    if s.startswith("0x") or s.startswith("0X"):
        return Integer(int(s, _sage_const_16 ))
    return Integer(int(s, _sage_const_10 ))

def extract_curve_and_B():
    p = _sage_const_0xa15c4fb663a578d8b2496d3151a946119ee42695e18e13e90600192b1d0abdbb6f787f90c8d102ff88e284dd4526f5f6b6c980bf88f1d0490714b67e8a2a2b77 
    a = _sage_const_0x5e009506fcc7eff573bc960d88638fe25e76a9b6c7caeea072a27dcd1fa46abb15b7b6210cf90caba982893ee2779669bac06e267013486b22ff3e24abae2d42 
    b = _sage_const_0x2ce7d1ca4493b0977f088f6d30d9241f8048fdea112cc385b793bce953998caae680864a7d3aa437ea3ffd1441ca3fb352b0b710bb3f053e980e503be9a7fece 

    bx = _sage_const_0x7f0489e4efe6905f039476db54f9b6eac654c780342169155344abc5ac90167adc6b8dabacec643cbe420abffe9760cbc3e8a2b508d24779461c19b20e242a38 
    by = _sage_const_0xdd04134e747354e5b9618d8cb3f60e03a74a709d4956641b234daa8a65d43df34e18d00a59c070801178d198e8905ef670118c15b0906d3a00a662d3a2736bf 

    # Construct curve and Bob's point
    E = EllipticCurve(GF(p), [a, b])
    B = E(bx, by)
    return E, B

def extract_points_and_cipher(E):
    G = (_sage_const_3034712809375537908102988750113382444008758539448972750581525810900634243392172703684905257490982543775233630011707375189041302436945106395617312498769005 , _sage_const_4986645098582616415690074082237817624424333339074969364527548107042876175480894132576399611027847402879885574130125050842710052291870268101817275410204850 )
    A = (_sage_const_4748198372895404866752111766626421927481971519483471383813044005699388317650395315193922226704604937454742608233124831870493636003725200307683939875286865 , _sage_const_2421873309002279841021791369884483308051497215798017509805302041102468310636822060707350789776065212606890489706597369526562336256272258544226688832663757 )
    G = E(Integer(G[_sage_const_0 ]), Integer(G[_sage_const_1 ]))
    A = E(Integer(A[_sage_const_0 ]), Integer(A[_sage_const_1 ]))

    # Parse the dict with iv and ciphertext
    iv = bytes.fromhex('719700b2470525781cc844db1febd994')
    ct = bytes.fromhex('335470f413c225b705db2e930b9d460d3947b3836059fb890b044e46cbb343f0')
    return G, A, iv, ct

def SmartAttack(P,Q,p):
    E = P.curve()
    Eqp = EllipticCurve(Qp(p, _sage_const_2 ), [ ZZ(t) + randint(_sage_const_0 ,p)*p for t in E.a_invariants() ])

    P_Qps = Eqp.lift_x(ZZ(P.xy()[_sage_const_0 ]), all=True)
    for P_Qp in P_Qps:
        if GF(p)(P_Qp.xy()[_sage_const_1 ]) == P.xy()[_sage_const_1 ]:
            break

    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[_sage_const_0 ]), all=True)
    for Q_Qp in Q_Qps:
        if GF(p)(Q_Qp.xy()[_sage_const_1 ]) == Q.xy()[_sage_const_1 ]:
            break
    p_times_P = p*P_Qp
    p_times_Q = p*Q_Qp
    x_P,y_P = p_times_P.xy()
    x_Q,y_Q = p_times_Q.xy()
    phi_P = -(x_P/y_P)
    phi_Q = -(x_Q/y_Q)
    k = phi_Q/phi_P
    return ZZ(k)

def derive_key_from_point(S):
    # Matches the generator's KDF: key = SHA1(str(S))[:16]
    h = hashlib.sha1(str(S).encode('ascii')).digest()
    return h[:_sage_const_16 ]



# ---------- main ----------

# Build curve & read Bob's fixed pubkey (B) from the source file; the encryptor hardcodes B inside source_exceptional_curves.sage
E, B = extract_curve_and_B()

# Pull the ephemeral public key A, the printed generator G, and the ciphertext from the output file
G, A, iv, ct = extract_points_and_cipher(E)

# Sanity: curve should be anomalous -> Smart attack feasible
p = E.base_field().order()
order = E.order()
if order != p:
    print(f"[!] Warning: curve order != p (order={order}, p={p}). Smart attack is intended for anomalous curves (#E(F_p)=p). Proceeding anyway...")

# Recover nA s.t. A = nA*G
print("[*] Running Smart attack to recover ephemeral secret nA ...")
nA = SmartAttack(G, A, p)
print(f"[+] Recovered nA = {nA}")

# ECDH shared secret as used in the encryptor: secret = nA * B
secret = (nA * B).xy()[_sage_const_0 ]
sha1 = hashlib.sha1()
sha1.update(str(secret).encode('ascii'))
key = sha1.digest()[:_sage_const_16 ]
print("key= ", key)

